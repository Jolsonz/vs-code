// 爱丁顿数
// 借鉴的思路，写是自己写的
// 题目输入数据中给出一个数字n表示骑行的天数，并且给出了每天对应的骑行距离。想要找出有E天超过E英里，很容易想到先对这些天的骑行距离进行排序
// 从最大的骑行距离开始扫，2 3 6 6 7 7 8 8 9 10  一个一个来 10的时候，第一天，(1天超过1 英里) ；9的时候，(2天超过2英里)；8的时候(3天超过3英里)；8的时候(4天超过4英里)；7的时候(5天超过5英里)；7的时候(6天超过6英里)；6的时候(7天超过7英里)这里得出了矛盾，即第7天的时候，骑行的英里数没有超过7(<=7)扫到这里的时候跳出循环，输出上一个天数。

#include<bits/stdc++.h>
using namespace std;
bool cmp(int a, int b){
    return a>b;
}
int main() {
    int n;
    cin>>n;
    int a[n];
    for(int i=0;i<n;i++) cin>>a[i];
    sort(a,a+n,cmp);
    for(int i=0;i<n;i++){
        if(a[n-1]>n){cout<<n;break;}//指n小于a[]中最小值的情况，这时候直接输出。
        if(a[i]>i+1) continue;
        else {cout<<i;break;}//等到不满足条件的时候就要输出i
    }
    return 0;
}